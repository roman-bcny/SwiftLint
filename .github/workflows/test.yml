name: Test

on:
  push:
    branches: [main]
  pull_request:

permissions:
  contents: read

env:
  SKIP_INTEGRATION_TESTS: 'true'

jobs:
  spm_linux:
    if: false
    name: SPM, Linux, Swift 6.2
    runs-on: ubuntu-24.04
    container: swift:6.2-noble
    steps:
      - uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0
        with:
          persist-credentials: false
      - name: Get Swift version
        id: swift_version
        run: echo "version=$(swift --version | grep '[5-9]\.[0-9]\+\(\.[0-9]\)\?' -o | head -1)" >> "$GITHUB_OUTPUT"
      - uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          key: ${{ runner.os }}-spm-${{ steps.swift_version.outputs.version }}-${{ hashFiles('Package.resolved', 'Package.swift') }}
          restore-keys: ${{ runner.os }}-spm-${{ steps.swift_version.outputs.version }}-
          path: .build
      - name: Run tests
        uses: ./.github/actions/run-make
        with:
          rule: spm_test

  spm_macos:
    if: false
    name: SPM, macOS ${{ matrix.macOS }}, Xcode ${{ matrix.xcode }}
    runs-on: macos-${{ matrix.macOS }}
    strategy:
      matrix:
        include:
          - macOS: '14'
            xcode: '16.2'
          - macOS: '15'
            xcode: '16.4'
          - macOS: '26'
            xcode: '26.0'
    env:
      DEVELOPER_DIR: /Applications/Xcode_${{ matrix.xcode }}.app
    steps:
      - uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0
        with:
          persist-credentials: false
      - uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          key: ${{ runner.os }}-xcode-spm-${{ matrix.xcode }}-${{ hashFiles('Package.resolved', 'Package.swift') }}
          restore-keys: ${{ runner.os }}-xcode-spm-${{ matrix.xcode }}-
          path: .build
      - name: Run tests
        run: make spm_test

  spm_windows:
    name: SPM, Windows ${{ matrix.windows-display-name }}, Swift ${{ matrix.swift-version }}
    runs-on: windows-${{ matrix.windows-version }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - windows-version: 2025
            arch: amd64
            windows-display-name: 'Server 2025'
            swift-version: 6.2.1
    steps:
      - uses: compnerd/gha-setup-swift@main
        with:
          swift-version: swift-${{ matrix.swift-version }}-release
          swift-build: ${{ matrix.swift-version }}-RELEASE
          build_arch: ${{ matrix.arch }}
      - name: Enable long path support
        run: |
          reg add "HKLM\SYSTEM\CurrentControlSet\Control\FileSystem" /v LongPathsEnabled /t REG_DWORD /d 1 /f
      - uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0
        with:
          persist-credentials: false
      - uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          key: windows-${{ matrix.windows-version }}-spm-${{ matrix.swift-version }}-${{ hashFiles('Package.resolved', 'Package.swift') }}
          restore-keys: windows-${{ matrix.windows-version }}-spm-${{ matrix.swift-version }}-
          path: .build
      - name: Create monitoring wrapper script
        shell: powershell
        run: |
          $wrapperScript = @'
          param([string]$Command)
          
          # Capture current directory
          $workDir = Get-Location
          
          # Start monitoring in background
          $monitorJob = Start-Job -ScriptBlock {
            while ($true) {
              $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
              Write-Output "`n=== MONITOR $timestamp ==="
              
              # Swift processes count grouped by name
              $swiftProcs = Get-Process -ErrorAction SilentlyContinue | Where-Object { $_.ProcessName -like "*swift*" } | Group-Object ProcessName
              if ($swiftProcs) {
                Write-Output "Swift Processes:"
                $swiftProcs | ForEach-Object { Write-Output "  $($_.Name): $($_.Count)" }
              } else {
                Write-Output "Swift Processes: None"
              }
              
              # CPU and Memory
              $cpu = (Get-Counter '\Processor(_Total)\% Processor Time').CounterSamples.CookedValue
              $mem = Get-CimInstance Win32_OperatingSystem
              $usedGB = [math]::Round(($mem.TotalVisibleMemorySize - $mem.FreePhysicalMemory) / 1MB, 2)
              $totalGB = [math]::Round($mem.TotalVisibleMemorySize / 1MB, 2)
              
              Write-Output "CPU Usage: $([math]::Round($cpu, 2))%"
              Write-Output "Memory: $usedGB GB / $totalGB GB"
              
              Start-Sleep -Seconds 10
            }
          }
          
          # Start command in background job with working directory
          $commandJob = Start-Job -ScriptBlock {
            param([string]$Cmd, [string]$WorkDir)
            Set-Location $WorkDir
            
            # Execute command and capture all output
            $ErrorActionPreference = 'Continue'
            Invoke-Expression $Cmd 2>&1 | ForEach-Object { 
              Write-Output $_ 
            }
            
            # Capture and return the exit code
            $exitCode = $LASTEXITCODE
            if ($null -eq $exitCode) { $exitCode = 0 }
            
            Write-Output "EXIT_CODE:$exitCode"
          } -ArgumentList $Command, $workDir.Path
          
          # Poll both jobs and show output as it comes
          while ($commandJob.State -eq 'Running') {
            $monitorOutput = Receive-Job $monitorJob
            if ($monitorOutput) {
              $monitorOutput | ForEach-Object { Write-Output $_ }
            }
            
            $commandOutput = Receive-Job $commandJob
            if ($commandOutput) {
              $commandOutput | ForEach-Object { Write-Output $_ }
            }
            
            Start-Sleep -Milliseconds 500
          }
          
          # Get all remaining output - critical for not truncating logs
          Write-Output "`n=== Retrieving remaining monitor output ==="
          $finalMonitorOutput = Receive-Job $monitorJob
          if ($finalMonitorOutput) {
            $finalMonitorOutput | ForEach-Object { Write-Output $_ }
          }
          
          Write-Output "`n=== Retrieving remaining command output ==="
          $finalCommandOutput = Receive-Job $commandJob -Wait
          
          # Extract exit code and output
          $exitCode = 0
          if ($finalCommandOutput) {
            foreach ($line in $finalCommandOutput) {
              if ($line -match '^EXIT_CODE:(\d+)$') {
                $exitCode = [int]$matches[1]
              } else {
                Write-Output $line
              }
            }
          }
          
          # Clean up
          Stop-Job $monitorJob -ErrorAction SilentlyContinue
          Remove-Job $monitorJob -ErrorAction SilentlyContinue
          Remove-Job $commandJob -ErrorAction SilentlyContinue
          
          Write-Output "`n=== Command exited with code: $exitCode ==="
          
          if ($exitCode -ne 0) {
            exit $exitCode
          }
          '@
          $wrapperScript | Out-File -FilePath monitor-wrapper.ps1 -Encoding UTF8
      - name: Build all targets
        shell: powershell
        run: |
          .\monitor-wrapper.ps1 -Command "swift build --build-tests"
      - name: List available tests
        run: swift test list
      - name: Run selected tests
        shell: powershell
        run: |
          .\monitor-wrapper.ps1 -Command "swift test --skip IntegrationTests --skip FileSystemAccessTests"
      - name: Run all tests
        shell: powershell
        run: |
          .\monitor-wrapper.ps1 -Command "swift test"
      # To be extended with test execution and linting ...
